<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tabular Transformer</title>
  <style>
    .container { width: 90%; margin: auto; text-align: center; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    table, th, td { border: 1px solid black; }
    th, td { padding: 6px; text-align: left; font-size: 13px; }
    input, select { margin: 5px; padding: 6px; width: 200px; }
    button { margin: 5px; padding: 8px 16px; cursor: pointer;
             background-color: #4CAF50; color: white; border: none; border-radius: 4px; }
    button:disabled { background-color: #cccccc; cursor: not-allowed; }
    #status { color: red; margin-top: 10px; }
    h3 { margin-top: 20px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Tabular Transformer</h1>

    <!-- Step 1: Upload -->
    <div>
      <label for="upload">1. Upload CSV or Excel File:</label><br>
      <input type="file" id="upload" accept=".csv, .xlsx, .xls" />
    </div>

    <!-- Step 2: Preview input -->
    <h3>Data Preview (Top 5 rows)</h3>
    <table id="preview"></table>

    <!-- Step 3: Fixed Columns -->
    <div>
      <label for="fixedColumns">2. Fixed Data Range (e.g., 1:3):</label><br>
      <input type="text" id="fixedColumns" placeholder="Enter fixed column range" disabled />
    </div>

    <!-- Step 4: Repeat Group Size -->
    <div>
      <label for="repeatSize">3. Repeat Group Size (e.g., 3,4,5,â€¦):</label><br>
      <input type="number" id="repeatSize" min="1" placeholder="Enter group size" disabled />
    </div>

    <!-- Step 5: Repeat Columns Range -->
    <div>
      <label for="repeatRange">4. Repeat Columns Range (e.g., 4:n):</label><br>
      <input type="text" id="repeatRange" placeholder="Start:End" disabled />
    </div>

    <!-- Step 6: Process -->
    <button id="processBtn" disabled onclick="processData()">5. Process</button>

    <!-- Step 7: Output Preview -->
    <h3>Processed Data Preview (Top 5 rows)</h3>
    <table id="outputPreview"></table>

    <!-- Step 8: Download -->
    <button id="downloadExcelBtn" disabled onclick="downloadExcel()">Download Excel</button>
    <button id="downloadCsvBtn" disabled onclick="downloadCSV()">Download CSV</button>

    <p id="status"></p>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script>
    let rawData = null;
    let processedData = null;
    let fixedColumns = null;

    const uploadInput = document.getElementById("upload");
    const fixedColumnsInput = document.getElementById("fixedColumns");
    const repeatSizeInput = document.getElementById("repeatSize");
    const repeatRangeInput = document.getElementById("repeatRange");
    const processBtn = document.getElementById("processBtn");
    const status = document.getElementById("status");

    // Handle file upload
    uploadInput.addEventListener("change", function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const wb = XLSX.read(e.target.result, { type: 'binary' });
        const ws = wb.Sheets[wb.SheetNames[0]];
        rawData = XLSX.utils.sheet_to_json(ws, { header: 1 }).filter(r => r.some(c => c));

        // Suggest fixed columns automatically
        fixedColumnsInput.disabled = false;
        fixedColumnsInput.value = "1:3";
        repeatSizeInput.disabled = false;
        repeatRangeInput.disabled = false;
        processBtn.disabled = false;

        previewData(rawData, "preview");
        status.textContent = "";
      };
      reader.readAsBinaryString(file);
    });

    // Preview function
    function previewData(data, tableId) {
      const table = document.getElementById(tableId);
      table.innerHTML = "";
      if (!data || data.length === 0) return;

      // Header row
      const headerRow = document.createElement("tr");
      data[0].forEach((_, i) => {
        const th = document.createElement("th");
        th.textContent = `Col ${i+1}`;
        headerRow.appendChild(th);
      });
      table.appendChild(headerRow);

      // Top 5 rows
      data.slice(0,6).forEach(row => {
        const tr = document.createElement("tr");
        row.forEach(cell => {
          const td = document.createElement("td");
          td.textContent = cell || "";
          tr.appendChild(td);
        });
        table.appendChild(tr);
      });
    }

    // Parse range function
    function parseRange(range) {
      const parts = range.split(":");
      if (parts.length !== 2) return null;
      const start = parseInt(parts[0]) - 1;
      const end = parts[1].trim().toLowerCase() === "n" ? rawData[0].length - 1 : parseInt(parts[1]) - 1;
      return { start, end };
    }

    // Process data
    function processData() {
      fixedColumns = parseRange(fixedColumnsInput.value);
      if (!fixedColumns) { status.textContent = "Invalid fixed column range."; return; }

      const repeatGroupSize = parseInt(repeatSizeInput.value);
      if (!repeatGroupSize || repeatGroupSize < 1) { status.textContent = "Invalid repeat group size."; return; }

      const repeatColumns = parseRange(repeatRangeInput.value);
      if (!repeatColumns) { status.textContent = "Invalid repeat columns range."; return; }

      processedData = [];
      const headers = [...rawData[0].slice(fixedColumns.start, fixedColumns.end+1)];
      for (let i = 0; i < repeatGroupSize; i++) headers.push("Group" + (i+1));
      processedData.push(headers);

      rawData.slice(1).forEach(row => {
        const fixedPart = row.slice(fixedColumns.start, fixedColumns.end+1);

        for (let i = repeatColumns.start; i <= repeatColumns.end; i += repeatGroupSize) {
          const group = row.slice(i, i + repeatGroupSize);
          if (group.length === 0) continue;
          processedData.push([...fixedPart, ...group]);
        }
      });

      previewData(processedData, "outputPreview");
      document.getElementById("downloadExcelBtn").disabled = false;
      document.getElementById("downloadCsvBtn").disabled = false;
      status.textContent = "Processed successfully!";
    }

    // Download Excel
    function downloadExcel() {
      const ws = XLSX.utils.aoa_to_sheet(processedData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Processed");
      XLSX.writeFile(wb, "processed_data.xlsx");
    }

    // Download CSV
    function downloadCSV() {
      const csv = processedData.map(r => r.map(v => `"${v||""}"`).join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "processed_data.csv";
      link.click();
    }
  </script>
</body>
        </html>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script>
    let rawData = null;
    let processedData = null;
    let fixedColumns = null;
    let repeatColumns = null;

    const uploadInput = document.getElementById("upload");
    const fixedColumnsInput = document.getElementById("fixedColumns");
    const repeatPattern = document.getElementById("repeatPattern");
    const repeatColumnsInput = document.getElementById("repeatColumns");
    const customRangeDiv = document.getElementById("customRangeDiv");
    const processBtn = document.getElementById("processBtn");
    const status = document.getElementById("status");

    uploadInput.addEventListener("change", handleFileUpload);

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const wb = XLSX.read(e.target.result, { type: 'binary' });
        const ws = wb.Sheets[wb.SheetNames[0]];
        rawData = XLSX.utils.sheet_to_json(ws, { header: 1 }).filter(r => r.some(c => c));

        // Suggest fixed columns (first 2-3 cols)
        fixedColumnsInput.disabled = false;
        fixedColumnsInput.value = "1:3";
        repeatPattern.disabled = false;
        previewData(rawData, "preview");
        status.textContent = "";
      };
      reader.readAsBinaryString(file);
    }

    function previewData(data, tableId) {
      const table = document.getElementById(tableId);
      table.innerHTML = "";
      if (!data || data.length === 0) return;

      // Header row
      const headerRow = document.createElement("tr");
      data[0].forEach((_, i) => {
        const th = document.createElement("th");
        th.textContent = `Col ${i+1}`;
        headerRow.appendChild(th);
      });
      table.appendChild(headerRow);

      // First 5 rows
      data.slice(0, 6).forEach(row => {
        const tr = document.createElement("tr");
        row.forEach(cell => {
          const td = document.createElement("td");
          td.textContent = cell || "";
          tr.appendChild(td);
        });
        table.appendChild(tr);
      });
    }

    function parseRange(range) {
      if (!range) return null;
      const parts = range.split(":");
      if (parts.length !== 2) return null;
      const start = parseInt(parts[0]) - 1;
      const end = parts[1].trim() === "n" ? rawData[0].length - 1 : parseInt(parts[1]) - 1;
      return { start, end };
    }

    repeatPattern.addEventListener("change", () => {
      if (repeatPattern.value === "custom") {
        customRangeDiv.style.display = "block";
      } else {
        customRangeDiv.style.display = "none";
        processBtn.disabled = false;
      }
    });

    repeatColumnsInput.addEventListener("input", () => {
      repeatColumns = parseRange(repeatColumnsInput.value);
      processBtn.disabled = !repeatColumns;
    });

    function processData() {
      fixedColumns = parseRange(fixedColumnsInput.value);
      if (!fixedColumns) {
        status.textContent = "Invalid fixed column range.";
        return;
      }

      let patternSize = 0;
      if (repeatPattern.value === "triplet") patternSize = 3;
      else if (repeatPattern.value === "forthlet") patternSize = 4;
      else if (repeatPattern.value === "custom") {
        repeatColumns = parseRange(repeatColumnsInput.value);
        if (!repeatColumns) {
          status.textContent = "Invalid repeat range.";
          return;
        }
      }

      processedData = [];
      const headers = [
        ...rawData[0].slice(fixedColumns.start, fixedColumns.end + 1),
        "Group1", "Group2", "Group3", "Group4"
      ];
      processedData.push(headers);

      rawData.slice(1).forEach(row => {
        const fixedPart = row.slice(fixedColumns.start, fixedColumns.end + 1);
        let start = fixedColumns.end + 1;
        let end = row.length;

        if (repeatPattern.value === "custom" && repeatColumns) {
          start = repeatColumns.start;
          end = repeatColumns.end + 1;
        }

        for (let i = start; i < end; i += patternSize || (end - start)) {
          const group = row.slice(i, i + (patternSize || (end - start)));
          if (group.length === 0) continue;
          processedData.push([...fixedPart, ...group]);
        }
      });

      previewData(processedData, "outputPreview");
      document.getElementById("downloadExcelBtn").disabled = false;
      document.getElementById("downloadCsvBtn").disabled = false;
      status.textContent = "Processed successfully!";
    }

    function downloadExcel() {
      const ws = XLSX.utils.aoa_to_sheet(processedData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Processed");
      XLSX.writeFile(wb, "processed_data.xlsx");
    }

    function downloadCSV() {
      let csv = processedData.map(r => r.map(v => `"${v||""}"`).join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "processed_data.csv";
      link.click();
    }
  </script>
</body>
  </html>
